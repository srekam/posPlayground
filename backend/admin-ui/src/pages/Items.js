import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  Grid,
  Button,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  CircularProgress,
  Alert,
  Chip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Card,
  CardContent,
  Tab,
  Tabs,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Switch,
  FormControlLabel,
  IconButton,
  Tooltip,
  Badge,
  Stack,
  Pagination,
  Checkbox,
} from '@mui/material';
import {
  Add,
  Edit,
  Delete,
  Inventory,
  AttachMoney,
  LocationOn,
  Search,
  FilterList,
  MoreVert,
  Visibility,
  ContentCopy,
  Warning,
  CheckCircle,
  Error,
  Receipt,
  ShoppingCart,
  Timer,
  Upgrade,
  LocalShipping,
  Category,
  Image,
  Assessment,
} from '@mui/icons-material';
import apiClient, { API_ENDPOINTS } from '../config/api';
import ItemEditor from '../components/ItemEditor';
import InventoryManager from '../components/InventoryManager';
import BundleManager from '../components/BundleManager';
import AccessZonesManager from '../components/AccessZonesManager';
import QuickActions from '../components/QuickActions';

// Item type configurations
const ITEM_TYPES = {
  STOCKED_GOOD: { label: 'Stocked Good', icon: <LocalShipping />, color: 'primary' },
  NON_STOCKED_SERVICE: { label: 'Service', icon: <Receipt />, color: 'secondary' },
  PASS_TIME: { label: 'Pass (Time)', icon: <Timer />, color: 'success' },
  RIDE_CREDIT_BUNDLE: { label: 'Ride Bundle', icon: <ShoppingCart />, color: 'info' },
  SINGLE_RIDE: { label: 'Single Ride', icon: <ShoppingCart />, color: 'info' },
  BUNDLE: { label: 'Bundle', icon: <Inventory />, color: 'warning' },
  UPGRADE: { label: 'Upgrade', icon: <Upgrade />, color: 'error' },
  FEE: { label: 'Fee', icon: <AttachMoney />, color: 'default' },
  DISCOUNT: { label: 'Discount', icon: <AttachMoney />, color: 'default' },
};

export default function Items() {
  // State management
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [items, setItems] = useState([]);
  const [categories, setCategories] = useState([]);
  const [activeTab, setActiveTab] = useState(0);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [dialogMode, setDialogMode] = useState('add');
  const [selectedItem, setSelectedItem] = useState(null);
  
  // Filters and pagination
  const [filters, setFilters] = useState({
    type: '',
    category_id: '',
    active: '',
    q: '',
  });
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 50,
    total: 0,
  });
  
  // Bulk actions
  const [selectedItems, setSelectedItems] = useState([]);
  const [bulkAction, setBulkAction] = useState('');

  // Load data on component mount
  useEffect(() => {
    loadItems();
    loadCategories();
  }, [filters, pagination.page]);

  const loadItems = async () => {
    setLoading(true);
    setError('');
    try {
      const params = new URLSearchParams();
      Object.entries(filters).forEach(([key, value]) => {
        if (value) params.append(key, value);
      });
      params.append('page', pagination.page);
      params.append('limit', pagination.limit);

      const response = await apiClient.get(`${API_ENDPOINTS.ITEMS.LIST}?${params}`);
      
      // Handle our API response structure
      if (response.data && response.data.data) {
        setItems(response.data.data || []);
        setPagination(prev => ({
          ...prev,
          total: response.data.data.length || 0, // For now, use array length
        }));
      } else {
        setItems([]);
      }
    } catch (err) {
      console.error('Error loading items:', err);
      setError(err.response?.data?.message || err.message || 'Failed to load items');
    } finally {
      setLoading(false);
    }
  };

  const loadCategories = async () => {
    try {
      const response = await apiClient.get(API_ENDPOINTS.CATEGORIES.LIST);
      if (response.data && response.data.data) {
        setCategories(response.data.data || []);
      } else {
        setCategories([]);
      }
    } catch (err) {
      console.error('Error loading categories:', err);
      setCategories([]); // Set empty array on error
    }
  };

  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };

  const handleAdd = () => {
    setDialogMode('add');
    setSelectedItem(null);
    setDialogOpen(true);
  };

  const handleEdit = (item) => {
    setDialogMode('edit');
    setSelectedItem(item);
    setDialogOpen(true);
  };

  const handleClone = async (item) => {
    try {
      const clonedItem = {
        ...item,
        name: `${item.name} (Copy)`,
        item_id: undefined, // Will be generated by backend
      };
      delete clonedItem.created_at;
      delete clonedItem.updated_at;
      
      const response = await apiClient.post(API_ENDPOINTS.ITEMS.CREATE, clonedItem);
      if (response.data && response.data.data) {
        setError('');
        setSuccess('Item cloned successfully!');
        loadItems();
        
        // Auto-hide success message after 3 seconds
        setTimeout(() => setSuccess(''), 3000);
      }
    } catch (err) {
      console.error('Error cloning item:', err);
      setError(err.response?.data?.message || err.message || 'Failed to clone item');
    }
  };

  const handleDelete = async (item) => {
    if (window.confirm(`Are you sure you want to delete "${item.name}"?`)) {
      try {
        await apiClient.delete(API_ENDPOINTS.ITEMS.DELETE(item.item_id));
        setError('');
        setSuccess('Item deleted successfully!');
        loadItems();
        
        // Auto-hide success message after 3 seconds
        setTimeout(() => setSuccess(''), 3000);
      } catch (err) {
        console.error('Error deleting item:', err);
        setError(err.response?.data?.message || err.message || 'Failed to delete item');
      }
    }
  };

  const handleStatusToggle = async (item) => {
    try {
      await apiClient.patch(API_ENDPOINTS.ITEMS.UPDATE_STATUS(item.item_id), {
        active: !item.active
      });
      setError('');
      setSuccess('Item status updated successfully!');
      loadItems();
      
      // Auto-hide success message after 3 seconds
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      console.error('Error updating item status:', err);
      setError(err.response?.data?.message || err.message || 'Failed to update item status');
    }
  };

  const handleBulkAction = async () => {
    if (!bulkAction || selectedItems.length === 0) return;

    try {
      const promises = selectedItems.map(itemId => {
        const item = items.find(i => i.item_id === itemId);
        if (bulkAction === 'activate') {
          return apiClient.patch(API_ENDPOINTS.ITEMS.UPDATE_STATUS(itemId), { active: true });
        } else if (bulkAction === 'deactivate') {
          return apiClient.patch(API_ENDPOINTS.ITEMS.UPDATE_STATUS(itemId), { active: false });
        }
        return Promise.resolve();
      });

      await Promise.all(promises);
      setError('');
      setSuccess(`Bulk action completed for ${selectedItems.length} item(s)!`);
      loadItems();
      setSelectedItems([]);
      setBulkAction('');
      
      // Auto-hide success message after 3 seconds
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      console.error('Error performing bulk action:', err);
      setError(err.response?.data?.message || err.message || 'Failed to perform bulk action');
    }
  };

  const handleFilterChange = (field, value) => {
    setFilters(prev => ({ ...prev, [field]: value }));
    setPagination(prev => ({ ...prev, page: 1 }));
  };

  const handleSelectAll = (event) => {
    if (event.target.checked) {
      setSelectedItems(items.map(item => item.item_id));
    } else {
      setSelectedItems([]);
    }
  };

  const handleSelectItem = (itemId, checked) => {
    if (checked) {
      setSelectedItems(prev => [...prev, itemId]);
    } else {
      setSelectedItems(prev => prev.filter(id => id !== itemId));
    }
  };

  const handleDialogClose = () => {
    setDialogOpen(false);
    setSelectedItem(null);
  };

  const handleDialogSave = () => {
    loadItems();
    handleDialogClose();
  };

  const formatPrice = (satang) => {
    return `à¸¿${(satang / 100).toFixed(2)}`;
  };

  const getItemTypeInfo = (type) => {
    return ITEM_TYPES[type] || { label: type, icon: <Category />, color: 'default' };
  };

  const renderFilters = () => (
    <Paper sx={{ p: 2, mb: 2 }}>
      <Grid container spacing={2} alignItems="center">
        <Grid item xs={12} md={3}>
          <TextField
            fullWidth
            label="Search items"
            value={filters.q}
            onChange={(e) => handleFilterChange('q', e.target.value)}
            InputProps={{
              startAdornment: <Search sx={{ mr: 1, color: 'text.secondary' }} />,
            }}
          />
        </Grid>
        <Grid item xs={12} md={2}>
          <FormControl fullWidth>
            <InputLabel>Type</InputLabel>
            <Select
              value={filters.type}
              onChange={(e) => handleFilterChange('type', e.target.value)}
              label="Type"
            >
              <MenuItem value="">All Types</MenuItem>
              {Object.entries(ITEM_TYPES).map(([key, config]) => (
                <MenuItem key={key} value={key}>
                  <Stack direction="row" alignItems="center" spacing={1}>
                    {config.icon}
                    <span>{config.label}</span>
                  </Stack>
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Grid>
        <Grid item xs={12} md={2}>
          <FormControl fullWidth>
            <InputLabel>Category</InputLabel>
            <Select
              value={filters.category_id}
              onChange={(e) => handleFilterChange('category_id', e.target.value)}
              label="Category"
            >
              <MenuItem value="">All Categories</MenuItem>
              {categories.map((category) => (
                <MenuItem key={category.category_id} value={category.category_id}>
                  {category.name}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Grid>
        <Grid item xs={12} md={2}>
          <FormControl fullWidth>
            <InputLabel>Status</InputLabel>
            <Select
              value={filters.active}
              onChange={(e) => handleFilterChange('active', e.target.value)}
              label="Status"
            >
              <MenuItem value="">All Status</MenuItem>
              <MenuItem value="true">Active</MenuItem>
              <MenuItem value="false">Inactive</MenuItem>
            </Select>
          </FormControl>
        </Grid>
        <Grid item xs={12} md={3}>
          <Stack direction="row" spacing={1}>
            <Button
              variant="outlined"
              startIcon={<FilterList />}
              onClick={() => setFilters({ type: '', category_id: '', active: '', q: '' })}
            >
              Clear Filters
            </Button>
          </Stack>
        </Grid>
      </Grid>
    </Paper>
  );

  const renderBulkActions = () => {
    if (selectedItems.length === 0) return null;

    return (
      <Paper sx={{ p: 2, mb: 2, bgcolor: 'primary.light', color: 'primary.contrastText' }}>
        <Grid container spacing={2} alignItems="center">
          <Grid item>
            <Typography variant="body2">
              {selectedItems.length} item(s) selected
            </Typography>
          </Grid>
          <Grid item>
            <FormControl size="small" sx={{ minWidth: 120 }}>
              <InputLabel>Bulk Action</InputLabel>
              <Select
                value={bulkAction}
                onChange={(e) => setBulkAction(e.target.value)}
                label="Bulk Action"
              >
                <MenuItem value="activate">Activate</MenuItem>
                <MenuItem value="deactivate">Deactivate</MenuItem>
              </Select>
            </FormControl>
          </Grid>
          <Grid item>
            <Button
              variant="contained"
              onClick={handleBulkAction}
              disabled={!bulkAction}
              size="small"
            >
              Apply
            </Button>
          </Grid>
          <Grid item>
            <Button
              variant="outlined"
              onClick={() => setSelectedItems([])}
              size="small"
            >
              Clear
            </Button>
          </Grid>
        </Grid>
      </Paper>
    );
  };

  const renderItemsTable = () => (
    <TableContainer component={Paper}>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell padding="checkbox">
              <Checkbox
                checked={selectedItems.length === items.length && items.length > 0}
                indeterminate={selectedItems.length > 0 && selectedItems.length < items.length}
                onChange={handleSelectAll}
              />
            </TableCell>
            <TableCell>Name</TableCell>
            <TableCell>Type</TableCell>
            <TableCell>Price</TableCell>
            <TableCell>Category</TableCell>
            <TableCell>Status</TableCell>
            <TableCell>Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {items.map((item) => {
            const typeInfo = getItemTypeInfo(item.type);
            return (
              <TableRow key={item.item_id} hover>
                <TableCell padding="checkbox">
                  <Checkbox
                    checked={selectedItems.includes(item.item_id)}
                    onChange={(e) => handleSelectItem(item.item_id, e.target.checked)}
                  />
                </TableCell>
                <TableCell>
                  <Stack direction="row" alignItems="center" spacing={1}>
                    {item.images && item.images.length > 0 && (
                      <Image sx={{ fontSize: 20, color: 'text.secondary' }} />
                    )}
                    <Box>
                      <Typography variant="body2" fontWeight="medium">
                        {item.name}
                      </Typography>
                      {item.description && (
                        <Typography variant="caption" color="text.secondary">
                          {item.description.length > 50 
                            ? `${item.description.substring(0, 50)}...` 
                            : item.description}
                        </Typography>
                      )}
                    </Box>
                  </Stack>
                </TableCell>
                <TableCell>
                  <Chip
                    icon={typeInfo.icon}
                    label={typeInfo.label}
                    color={typeInfo.color}
                    size="small"
                  />
                </TableCell>
                <TableCell>
                  <Typography variant="body2" fontWeight="medium">
                    {formatPrice(item.price_satang)}
                  </Typography>
                  {item.type === 'STOCKED_GOOD' && item.stocked_good?.cost_satang && (
                    <Typography variant="caption" color="text.secondary">
                      Cost: {formatPrice(item.stocked_good.cost_satang)}
                    </Typography>
                  )}
                </TableCell>
                <TableCell>
                  {item.category_id ? (
                    categories.find(c => c.category_id === item.category_id)?.name || item.category_id
                  ) : (
                    <Typography variant="caption" color="text.secondary">No category</Typography>
                  )}
                </TableCell>
                <TableCell>
                  <FormControlLabel
                    control={
                      <Switch
                        checked={item.active}
                        onChange={() => handleStatusToggle(item)}
                        size="small"
                      />
                    }
                    label={item.active ? 'Active' : 'Inactive'}
                  />
                </TableCell>
                <TableCell>
                  <Stack direction="row" spacing={1}>
                    <Tooltip title="View">
                      <IconButton size="small" onClick={() => handleEdit(item)}>
                        <Visibility />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="Edit">
                      <IconButton size="small" onClick={() => handleEdit(item)}>
                        <Edit />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="Clone">
                      <IconButton size="small" onClick={() => handleClone(item)}>
                        <ContentCopy />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="Delete">
                      <IconButton size="small" color="error" onClick={() => handleDelete(item)}>
                        <Delete />
                      </IconButton>
                    </Tooltip>
                  </Stack>
                </TableCell>
              </TableRow>
            );
          })}
        </TableBody>
      </Table>
    </TableContainer>
  );

  const renderPagination = () => {
    const totalPages = Math.ceil(pagination.total / pagination.limit);
    if (totalPages <= 1) return null;

    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', mt: 2 }}>
        <Pagination
          count={totalPages}
          page={pagination.page}
          onChange={(event, page) => setPagination(prev => ({ ...prev, page }))}
          color="primary"
        />
      </Box>
    );
  };

  const getTabIcon = (index) => {
    const icons = [<Inventory />, <Assessment />, <ShoppingCart />, <LocationOn />, <Receipt />];
    return icons[index] || <Inventory />;
  };

  const getTabLabel = (index) => {
    const labels = ['Items', 'Inventory', 'Bundles', 'Access Zones', 'Quick Actions'];
    return labels[index] || 'Unknown';
  };

  const getTabCount = (index) => {
    const counts = [items.length, 0, 0, 0, 0]; // TODO: Get actual counts
    return counts[index] || 0;
  };

  return (
    <Box sx={{ p: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h4" component="h1">
          Items Management
        </Typography>
        {activeTab === 0 && (
          <Button
            variant="contained"
            startIcon={<Add />}
            onClick={handleAdd}
          >
            Add Item
          </Button>
        )}
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError('')}>
          {error}
        </Alert>
      )}

      {success && (
        <Alert severity="success" sx={{ mb: 2 }} onClose={() => setSuccess('')}>
          {success}
        </Alert>
      )}

      <Paper sx={{ mb: 2 }}>
        <Tabs value={activeTab} onChange={handleTabChange}>
          <Tab 
            icon={getTabIcon(0)} 
            label={`${getTabLabel(0)} (${getTabCount(0)})`}
            iconPosition="start"
          />
          <Tab 
            icon={getTabIcon(1)} 
            label={`${getTabLabel(1)} (${getTabCount(1)})`}
            iconPosition="start"
          />
          <Tab 
            icon={getTabIcon(2)} 
            label={`${getTabLabel(2)} (${getTabCount(2)})`}
            iconPosition="start"
          />
          <Tab 
            icon={getTabIcon(3)} 
            label={`${getTabLabel(3)} (${getTabCount(3)})`}
            iconPosition="start"
          />
          <Tab 
            icon={getTabIcon(4)} 
            label={`${getTabLabel(4)} (${getTabCount(4)})`}
            iconPosition="start"
          />
        </Tabs>
      </Paper>

      <Grid container spacing={3}>
        <Grid item xs={12}>
          {loading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
              <CircularProgress />
            </Box>
          ) : (
            <>
              {activeTab === 0 && (
                <>
                  {renderFilters()}
                  {renderBulkActions()}
                  {renderItemsTable()}
                  {renderPagination()}
                </>
              )}
              {activeTab === 1 && <InventoryManager />}
              {activeTab === 2 && <BundleManager />}
              {activeTab === 3 && <AccessZonesManager />}
              {activeTab === 4 && <QuickActions />}
            </>
          )}
        </Grid>
      </Grid>

      {/* Item Editor Dialog */}
      <ItemEditor
        open={dialogOpen}
        mode={dialogMode}
        item={selectedItem}
        categories={categories}
        onClose={handleDialogClose}
        onSave={handleDialogSave}
      />
    </Box>
  );
}